# -*- coding: utf-8 -*-
"""Challenge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PYTwkgqCDOcfHH9jjx1nwsgBHyHNZ6pf

Set Up The Environment installing all the necessary packages.
"""

!pip install fastapi uvicorn sqlalchemy pandas
!pip install Flask SQLAlchemy pandas psycopg2
!pip install Flask-SQLAlchemy
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from psycopg2 import DatabaseError
import pandas as pd
import numpy as np
import sqlite3
import psycopg2

"""Uploads the tables given."""

from google.colab import drive
drive.mount('/content/drive')

df_departments=pd.read_csv('/content/departments.csv')
df_departments

df_employees=pd.read_csv('/content/hired_employees.csv')
df_employees

df_jobs=pd.read_csv('/content/jobs.csv')
df_jobs

"""Create the Database setup(db) and Models using PostgreSQL"""

conn = sqlite3.connect('db.Model')

db = SQLAlchemy()

class df_departments(db.Model):
    __tablename__ = 'departments'
    department_id = db.Column(db.Integer, primary_key=True)
    department_name = db.Column(db.String, nullable=False)

class df_employees(db.Model):
    __tablename__ = 'employees'
    employee_id = db.Column(db.Integer, primary_key=True)
    employee_name = db.Column(db.String, nullable=False)
    department_id = db.Column(db.Integer, db.ForeignKey('departments.department_id'))

class df_jobs(db.Model):
    __tablename__ = 'jobs'
    job_id = db.Column(db.Integer, primary_key=True)
    job_title = db.Column(db.String, nullable=False)
    employee_id = db.Column(db.Integer, db.ForeignKey('employees.employee_id'))

"""Create API code with Flask application to handle file uploads and batch inserts."""

!pip install Flask Flask-SQLAlchemy mysqlclient

def get_connection():
    try:
        return psycopg2.connect(
            host="challenge-424505:us-central1:globant-challenge1502",
            user="postgres",
            password="Nmv980215s",
            database="postgres",
            port=5432
        )
       print("Connection to the database was successful.")
    except DatabaseError as ex:
        print("An error occurred while connecting to the database.")
        print(f"Error details: {ex}")
        raise ex

import os

UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file:
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        file.save(file_path)
        return jsonify({"message": "File uploaded successfully", "file_path": file_path}), 200

@app.route('/insert_batch', methods=['POST'])
def insert_batch():
    data = request.get_json()
    table_name = data.get('table')
    records = data.get('records')

    if not table_name or not records:
        return jsonify({"error": "Invalid request"}), 400

    if table_name == 'departments':
        model = Department
    elif table_name == 'jobs':
        model = Job
    elif table_name == 'employees':
        model = Employee
    else:
        return jsonify({"error": "Invalid table name"}), 400

    for record in records:
        row = model(**record)
        db.session.add(row)

    db.session.commit()
    return jsonify({"message": "Batch insert successful"}), 200

@app.route('/upload_and_insert', methods=['POST'])
def upload_and_insert():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file:
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        file.save(file_path)

        # Read CSV file
        df = pd.read_csv(file_path)
        table_name = request.form.get('table')

        if not table_name:
            return jsonify({"error": "No table specified"}), 400

        records = df.to_dict(orient='records')
        batch_size = 1000  # Define your batch size

        for i in range(0, len(records), batch_size):
            batch = records[i:i+batch_size]
            response = insert_batch_internal(table_name, batch)
            if response.status_code != 200:
                return response

        return jsonify({"message": "All data inserted successfully"}), 200

def insert_batch_internal(table_name, records):
    data = {
        "table": table_name,
        "records": records
    }
    with app.test_client() as client:
        response = client.post('/insert_batch', json=data)
    return response